create table "public"."avatars" (
    "id" bigint generated by default as identity not null,
    "name" text,
    "combination_key" text,
    "seed" text,
    "created_at" timestamp with time zone not null default now(),
    "origin_story" text,
    "core_drive" text,
    "public_persona" text,
    "power_play" text,
    "legacy_plan" text,
    "first_name" text,
    "last_name" text,
    "pose" text,
    "uploaded_at" timestamp with time zone default now(),
    "parsed_successfully" boolean default false,
    "updated_at" timestamp with time zone default now(),
    "character_story" text,
    "meta_data" jsonb,
    "asset_standing" text,
    "asset_riding" text,
    "asset_instagram" text,
    "asset_landscape" text,
    "asset_stories" text,
    "body_type" text,
    "hair_color" text,
    "hair_style" text,
    "skin_tone" text
);


alter table "public"."avatars" enable row level security;

create table "public"."selfies" (
    "id" bigint generated by default as identity not null,
    "user_id" bigint,
    "avatar_id" bigint,
    "asset" text,
    "created_at" timestamp with time zone not null default now(),
    "n_index" smallint,
    "status" text default ''::text,
    "meta" jsonb,
    "moderated_at" timestamp with time zone,
    "updated_at" timestamp without time zone default now(),
    "scene" text
);


alter table "public"."selfies" enable row level security;

create table "public"."user_avatars" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone,
    "user_id" bigint,
    "assigned_at" timestamp with time zone,
    "removed_at" text,
    "is_current" boolean,
    "avatar_id" bigint
);


alter table "public"."user_avatars" enable row level security;

create table "public"."user_cooldowns" (
    "id" bigint not null,
    "user_id" bigint,
    "action" text,
    "next_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "created_at" timestamp with time zone
);


alter table "public"."user_cooldowns" enable row level security;

create table "public"."user_selfies" (
    "id" bigint generated by default as identity not null,
    "user_id" bigint,
    "selfie_id" bigint,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."user_selfies" enable row level security;

create table "public"."user_videos" (
    "id" bigint generated by default as identity not null,
    "user_id" bigint,
    "video_id" bigint,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."user_videos" enable row level security;

create table "public"."users" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "avatar_id" bigint not null,
    "uuid" uuid not null default gen_random_uuid()
);


alter table "public"."users" enable row level security;

create table "public"."videos" (
    "id" bigint generated by default as identity not null,
    "avatar_id" bigint,
    "asset" text,
    "created_at" timestamp with time zone not null default now(),
    "n_index" smallint,
    "status" text default ''::text,
    "meta" jsonb,
    "moderated_at" timestamp with time zone
);


alter table "public"."videos" enable row level security;

CREATE UNIQUE INDEX avatars_pkey ON public.avatars USING btree (id);

CREATE INDEX idx_avatars_combination_key ON public.avatars USING btree (combination_key);

CREATE INDEX idx_avatars_core_drive ON public.avatars USING btree (core_drive);

CREATE INDEX idx_avatars_first_name ON public.avatars USING btree (first_name);

CREATE INDEX idx_avatars_last_name ON public.avatars USING btree (last_name);

CREATE INDEX idx_avatars_legacy_plan ON public.avatars USING btree (legacy_plan);

CREATE INDEX idx_avatars_name ON public.avatars USING btree (name);

CREATE INDEX idx_avatars_origin_story ON public.avatars USING btree (origin_story);

CREATE INDEX idx_avatars_parsed_successfully ON public.avatars USING btree (parsed_successfully);

CREATE INDEX idx_avatars_pose ON public.avatars USING btree (pose);

CREATE INDEX idx_avatars_power_play ON public.avatars USING btree (power_play);

CREATE INDEX idx_avatars_public_persona ON public.avatars USING btree (public_persona);

CREATE INDEX idx_avatars_traits ON public.avatars USING btree (origin_story, core_drive, public_persona, power_play, legacy_plan);

CREATE INDEX idx_avatars_uploaded_at ON public.avatars USING btree (uploaded_at);

CREATE UNIQUE INDEX selfies_pkey ON public.selfies USING btree (id);

CREATE UNIQUE INDEX user_avatars_one_current_per_user ON public.user_avatars USING btree (user_id) WHERE (is_current = true);

CREATE UNIQUE INDEX user_avatars_pkey ON public.user_avatars USING btree (id);

CREATE UNIQUE INDEX user_cooldowns_pkey ON public.user_cooldowns USING btree (id);

CREATE UNIQUE INDEX user_selfies_pkey ON public.user_selfies USING btree (id);

CREATE UNIQUE INDEX user_videos_pkey ON public.user_videos USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

CREATE UNIQUE INDEX users_uuid_key ON public.users USING btree (uuid);

CREATE UNIQUE INDEX videos_pkey ON public.videos USING btree (id);

alter table "public"."avatars" add constraint "avatars_pkey" PRIMARY KEY using index "avatars_pkey";

alter table "public"."selfies" add constraint "selfies_pkey" PRIMARY KEY using index "selfies_pkey";

alter table "public"."user_avatars" add constraint "user_avatars_pkey" PRIMARY KEY using index "user_avatars_pkey";

alter table "public"."user_cooldowns" add constraint "user_cooldowns_pkey" PRIMARY KEY using index "user_cooldowns_pkey";

alter table "public"."user_selfies" add constraint "user_selfies_pkey" PRIMARY KEY using index "user_selfies_pkey";

alter table "public"."user_videos" add constraint "user_videos_pkey" PRIMARY KEY using index "user_videos_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."videos" add constraint "videos_pkey" PRIMARY KEY using index "videos_pkey";

alter table "public"."user_avatars" add constraint "user_avatars_avatar_id_fkey" FOREIGN KEY (avatar_id) REFERENCES avatars(id) not valid;

alter table "public"."user_avatars" validate constraint "user_avatars_avatar_id_fkey";

alter table "public"."user_avatars" add constraint "user_avatars_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."user_avatars" validate constraint "user_avatars_user_id_fkey";

alter table "public"."user_cooldowns" add constraint "user_cooldowns_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."user_cooldowns" validate constraint "user_cooldowns_user_id_fkey";

alter table "public"."user_selfies" add constraint "user_selfies_selfie_id_fkey" FOREIGN KEY (selfie_id) REFERENCES selfies(id) not valid;

alter table "public"."user_selfies" validate constraint "user_selfies_selfie_id_fkey";

alter table "public"."user_selfies" add constraint "user_selfies_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."user_selfies" validate constraint "user_selfies_user_id_fkey";

alter table "public"."user_videos" add constraint "user_videos_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."user_videos" validate constraint "user_videos_user_id_fkey";

alter table "public"."user_videos" add constraint "user_videos_video_id_fkey" FOREIGN KEY (video_id) REFERENCES videos(id) not valid;

alter table "public"."user_videos" validate constraint "user_videos_video_id_fkey";

alter table "public"."users" add constraint "users_uuid_key" UNIQUE using index "users_uuid_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_available_choices(choice text)
 RETURNS TABLE(origin_story text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.origin_story
  FROM public.avatars AS a;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_available_selfies(p_uuid uuid)
 RETURNS TABLE(next_n bigint, next_at timestamp with time zone)
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
  DECLARE
    v_user_id   BIGINT;
    v_avatar_id BIGINT;
  BEGIN
    -------------------------------------------------------------------
    -- Step 1: Get user_id and avatar_id from UUID
    -------------------------------------------------------------------
    SELECT u.id, u.avatar_id
    INTO v_user_id, v_avatar_id
    FROM public.users u
    WHERE u.uuid = p_uuid;

    IF v_user_id IS NULL OR v_avatar_id IS NULL THEN
      RAISE NOTICE 'User with uuid % not found or missing avatar', p_uuid;
      RETURN;
    END IF;

    -------------------------------------------------------------------
    -- Step 2: Return count of user selfies and next_at from cooldowns
    -------------------------------------------------------------------
    RETURN QUERY
    SELECT
      COALESCE(
        (SELECT COUNT(*)
         FROM public.user_selfies us
         JOIN public.selfies s ON s.id = us.selfie_id
         WHERE us.user_id = v_user_id
           AND s.avatar_id = v_avatar_id), 0
      )::BIGINT AS next_n,
      uc.next_at AS next_at
    FROM public.user_cooldowns uc
    WHERE uc.user_id = v_user_id;

  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.get_avatar_standing_asset_by_user_uuid(user_uuid uuid)
 RETURNS TABLE(user_id bigint, avatar_id bigint, asset_standing text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        u.id as user_id,
        u.avatar_id,
        a.asset_standing
    FROM public.users AS u
    INNER JOIN public.avatars AS a ON u.avatar_id = a.id
    WHERE u.uuid = user_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_core_drives(selected_origin_story text)
 RETURNS TABLE(core_drive text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.core_drive
  FROM public.avatars AS a
  WHERE selected_origin_story = '' OR a.origin_story ILIKE selected_origin_story;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_legacy_plans(selected_origin_story text, selected_core_drive text, selected_public_mask text, selected_power_play text)
 RETURNS TABLE(legacy_plan text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.legacy_plan
  FROM public.avatars AS a
  WHERE 
    (selected_origin_story = '' OR a.origin_story ILIKE selected_origin_story)
    AND 
    (selected_core_drive = '' OR a.core_drive ILIKE selected_core_drive)
    AND 
    (selected_public_mask = '' OR a.public_persona ILIKE selected_public_mask)
    AND 
    (selected_power_play = '' OR a.power_play ILIKE selected_power_play);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_origin_stories()
 RETURNS TABLE(origin_story text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.origin_story
  FROM public.avatars AS a;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_power_plays(selected_origin_story text, selected_core_drive text, selected_public_mask text)
 RETURNS TABLE(power_play text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.power_play
  FROM public.avatars AS a
  WHERE 
    (selected_origin_story = '' OR a.origin_story ILIKE selected_origin_story)
    AND 
    (selected_core_drive = '' OR a.core_drive ILIKE selected_core_drive)
    AND 
    (selected_public_mask = '' OR a.public_persona ILIKE selected_public_mask);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_public_masks(selected_origin_story text, selected_core_drive text)
 RETURNS TABLE(public_mask text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT DISTINCT a.public_persona AS public_mask
  FROM public.avatars AS a
  WHERE 
    (selected_origin_story = '' OR a.origin_story ILIKE selected_origin_story)
    AND 
    (selected_core_drive = '' OR a.core_drive ILIKE selected_core_drive);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_random_avatar(search_pattern text)
 RETURNS TABLE(id bigint, combination_key text, asset_riding text, character_story text, first_name text, last_name text, asset_instagram text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$ BEGIN RETURN QUERY 
SELECT a.id, a.combination_key, a.asset_riding, a.character_story, a.first_name, a.last_name, a.asset_instagram
FROM public.avatars AS a WHERE a.combination_key ILIKE search_pattern || '%' ORDER BY pg_catalog.random() LIMIT 1; END; $function$
;

CREATE OR REPLACE FUNCTION public.get_random_avatar_v2(search_pattern text)
 RETURNS TABLE(id bigint, combination_key text, asset_riding text, character_story text, first_name text, last_name text, asset_instagram text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  -- Primer intento: buscar por patrón
  RETURN QUERY
  SELECT a.id, a.combination_key, a.asset_riding, a.character_story,
         a.first_name, a.last_name, a.asset_instagram
  FROM public.avatars AS a
  WHERE a.combination_key ILIKE search_pattern || '%'
  ORDER BY RANDOM()
  LIMIT 1;

  -- Si no encontró nada, hacer fallback
  IF NOT FOUND THEN
    RETURN QUERY
    SELECT a.id, a.combination_key, a.asset_riding, a.character_story,
           a.first_name, a.last_name, a.asset_instagram
    FROM public.avatars AS a
    ORDER BY RANDOM()
    LIMIT 1;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_random_avatar_v2(selected_origin_story text, selected_core_drive text, selected_public_mask text, selected_power_play text, selected_legacy_plan text)
 RETURNS TABLE(id bigint, combination_key text, asset_riding text, character_story text, first_name text, last_name text, asset_instagram text)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  -- First try: apply the filters received
  RETURN QUERY
  SELECT a.id, a.combination_key, a.asset_riding, a.character_story,
         a.first_name, a.last_name, a.asset_instagram
  FROM public.avatars AS a
  WHERE 
    (selected_origin_story = '' OR a.origin_story ILIKE selected_origin_story)
    AND (selected_core_drive = '' OR a.core_drive ILIKE selected_core_drive)
    AND (selected_public_mask = '' OR a.public_persona ILIKE selected_public_mask)
    AND (selected_power_play = '' OR a.power_play ILIKE selected_power_play)
    AND (selected_legacy_plan = '' OR a.legacy_plan ILIKE selected_legacy_plan)
  ORDER BY RANDOM()
  LIMIT 1;

  -- If nothing is found, fallback to a random avatar
  IF NOT FOUND THEN
    RETURN QUERY
    SELECT a.id, a.combination_key, a.asset_riding, a.character_story,
           a.first_name, a.last_name, a.asset_instagram
    FROM public.avatars AS a
    ORDER BY RANDOM()
    LIMIT 1;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_selfie_for_user_avatar(p_uuid uuid)
 RETURNS TABLE(asset text, id bigint, created_at timestamp with time zone, n_index smallint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_user_id   BIGINT;
  v_avatar_id BIGINT;
  v_selfie_id BIGINT;
  v_nindex    INT;
BEGIN
  -------------------------------------------------------------------
  -- Step 1: Find user id and current avatar id from users table
  -------------------------------------------------------------------
  SELECT u.id, u.avatar_id
  INTO v_user_id, v_avatar_id
  FROM public.users u
  WHERE u.uuid = p_uuid;

  IF v_user_id IS NULL OR v_avatar_id IS NULL THEN
    RAISE NOTICE 'User with uuid % not found or missing avatar', p_uuid;
    RETURN;
  END IF;

  -------------------------------------------------------------------
  -- Step 2: Determine the selfie index (n_index) to fetch next
  -------------------------------------------------------------------
  SELECT COUNT(*) + 1
  INTO v_nindex
  FROM public.user_selfies us
  WHERE us.user_id = v_user_id;

  RAISE NOTICE 'Next selfie index for user % is %', v_user_id, v_nindex;

  -------------------------------------------------------------------
  -- Step 3: Find the published selfie with that n_index for this avatar
  -------------------------------------------------------------------
  SELECT s.id
  INTO v_selfie_id
  FROM public.selfies s
  WHERE s.avatar_id = v_avatar_id
    AND s.n_index   = v_nindex
    AND s.status    = 'published'
  LIMIT 1;

  IF v_selfie_id IS NULL THEN
    RAISE NOTICE 'No selfie found for avatar id % and index %', v_avatar_id, v_nindex;
    RETURN;
  END IF;

  -------------------------------------------------------------------
  -- Step 4: Link user and selfie in user_selfies table
  -------------------------------------------------------------------
  INSERT INTO public.user_selfies (user_id, selfie_id)
  VALUES (v_user_id, v_selfie_id)
  ON CONFLICT DO NOTHING;

  -------------------------------------------------------------------
  -- Step 5: Upsert cooldown record for the user
  -------------------------------------------------------------------
  INSERT INTO public.user_cooldowns (user_id, action, next_at, updated_at)
  VALUES (
    v_user_id,
    'selfie',
    NOW() + INTERVAL '24 hours',
    NOW()
  )
  ON CONFLICT (user_id, action)
  DO UPDATE
  SET next_at   = EXCLUDED.next_at,
      updated_at = EXCLUDED.updated_at;

  -------------------------------------------------------------------
  -- Step 6: Return selfie data (asset, id, created_at, n_index)
  -------------------------------------------------------------------
  RETURN QUERY
  SELECT s.asset, s.id, s.created_at, s.n_index
  FROM public.selfies s
  WHERE s.id = v_selfie_id;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_avatar_by_uuid(user_uuid uuid)
 RETURNS TABLE(avatar_id bigint, asset_riding text, asset_instagram text, character_story text, first_name text, last_name text, selfies jsonb)
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
  BEGIN
      RETURN QUERY
      SELECT
          a.id as avatar_id,
          a.asset_riding,
          a.asset_instagram,
          a.character_story,
          a.first_name,
          a.last_name,
          COALESCE(
              jsonb_agg(
                  jsonb_build_object(
                      'id', s.id,
                      'asset', s.asset,
                      'created_at', s.created_at
                  )
              ) FILTER (WHERE s.id IS NOT NULL),
              '[]'::jsonb
          ) as selfies
      FROM public.users AS u
      INNER JOIN public.avatars AS a ON u.avatar_id = a.id
      LEFT JOIN public.selfies AS s ON s.user_id = u.id
      WHERE u.uuid = user_uuid
      GROUP BY u.id, a.id, a.asset_riding, a.asset_instagram, a.character_story,
  a.first_name, a.last_name;
  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.remove_avatar_by_user(p_uuid uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
  DECLARE
    v_user_id BIGINT;
  BEGIN
    -- Find user id from uuid
    SELECT u.id INTO v_user_id
    FROM users u
    WHERE u.uuid = p_uuid;

    -- If user doesn't exist, just exit quietly
    IF v_user_id IS NULL THEN
      RAISE NOTICE 'User with uuid % not found', p_uuid;
      RETURN;
    END IF;

    -- 1️⃣ Update user: clear current_avatar_id
    UPDATE users
    SET current_avatar_id = NULL
    WHERE uuid = p_uuid;

    -- 2️⃣ Update related avatars: set all is_current to false
    UPDATE user_avatars
    SET is_current = FALSE
    WHERE user_id = v_user_id;

  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_user_with_avatar(p_uuid text, p_avatar_id bigint)
 RETURNS TABLE(avatar_id bigint, created_at timestamp with time zone, id bigint, uuid uuid)
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
  DECLARE
    v_uid BIGINT;
    v_uuid UUID;
  BEGIN
    -- Normalize uuid: if p_uuid is empty or null, keep it null
    IF p_uuid IS NULL OR length(trim(p_uuid)) = 0 THEN
      v_uuid := NULL;
    ELSE
      v_uuid := p_uuid::UUID;
    END IF;

    -- Try to find user by uuid only if a valid one was provided
    IF v_uuid IS NOT NULL THEN
      SELECT u.id INTO v_uid
      FROM users u
      WHERE u.uuid = v_uuid;
    END IF;

    IF v_uid IS NULL THEN
      -- If no user found, insert a new user
      INSERT INTO users (avatar_id, created_at)
      VALUES (p_avatar_id, NOW())
      RETURNING users.id, users.uuid INTO v_uid, v_uuid;
    ELSE
      -- If user exists, update current avatar
      UPDATE users
      SET avatar_id = p_avatar_id
      WHERE users.uuid = v_uuid
      RETURNING users.id, users.uuid INTO v_uid, v_uuid;
    END IF;

    -- Reset is_current flag for all previous avatars of this user
    UPDATE user_avatars
    SET is_current = FALSE
    WHERE user_id = v_uid;

    -- Insert new avatar as the current one
    INSERT INTO user_avatars (user_id, avatar_id, is_current)
    VALUES (v_uid, p_avatar_id, TRUE);

    -- Return data from users table
    RETURN QUERY
    SELECT u.avatar_id,
           u.created_at,
           u.id,
           u.uuid
    FROM users u
    WHERE u.id = v_uid;

  END;
  $function$
;

grant delete on table "public"."avatars" to "anon";

grant insert on table "public"."avatars" to "anon";

grant references on table "public"."avatars" to "anon";

grant select on table "public"."avatars" to "anon";

grant trigger on table "public"."avatars" to "anon";

grant truncate on table "public"."avatars" to "anon";

grant update on table "public"."avatars" to "anon";

grant delete on table "public"."avatars" to "authenticated";

grant insert on table "public"."avatars" to "authenticated";

grant references on table "public"."avatars" to "authenticated";

grant select on table "public"."avatars" to "authenticated";

grant trigger on table "public"."avatars" to "authenticated";

grant truncate on table "public"."avatars" to "authenticated";

grant update on table "public"."avatars" to "authenticated";

grant delete on table "public"."avatars" to "service_role";

grant insert on table "public"."avatars" to "service_role";

grant references on table "public"."avatars" to "service_role";

grant select on table "public"."avatars" to "service_role";

grant trigger on table "public"."avatars" to "service_role";

grant truncate on table "public"."avatars" to "service_role";

grant update on table "public"."avatars" to "service_role";

grant delete on table "public"."selfies" to "anon";

grant insert on table "public"."selfies" to "anon";

grant references on table "public"."selfies" to "anon";

grant select on table "public"."selfies" to "anon";

grant trigger on table "public"."selfies" to "anon";

grant truncate on table "public"."selfies" to "anon";

grant update on table "public"."selfies" to "anon";

grant delete on table "public"."selfies" to "authenticated";

grant insert on table "public"."selfies" to "authenticated";

grant references on table "public"."selfies" to "authenticated";

grant select on table "public"."selfies" to "authenticated";

grant trigger on table "public"."selfies" to "authenticated";

grant truncate on table "public"."selfies" to "authenticated";

grant update on table "public"."selfies" to "authenticated";

grant delete on table "public"."selfies" to "service_role";

grant insert on table "public"."selfies" to "service_role";

grant references on table "public"."selfies" to "service_role";

grant select on table "public"."selfies" to "service_role";

grant trigger on table "public"."selfies" to "service_role";

grant truncate on table "public"."selfies" to "service_role";

grant update on table "public"."selfies" to "service_role";

grant delete on table "public"."user_avatars" to "anon";

grant insert on table "public"."user_avatars" to "anon";

grant references on table "public"."user_avatars" to "anon";

grant select on table "public"."user_avatars" to "anon";

grant trigger on table "public"."user_avatars" to "anon";

grant truncate on table "public"."user_avatars" to "anon";

grant update on table "public"."user_avatars" to "anon";

grant delete on table "public"."user_avatars" to "authenticated";

grant insert on table "public"."user_avatars" to "authenticated";

grant references on table "public"."user_avatars" to "authenticated";

grant select on table "public"."user_avatars" to "authenticated";

grant trigger on table "public"."user_avatars" to "authenticated";

grant truncate on table "public"."user_avatars" to "authenticated";

grant update on table "public"."user_avatars" to "authenticated";

grant delete on table "public"."user_avatars" to "service_role";

grant insert on table "public"."user_avatars" to "service_role";

grant references on table "public"."user_avatars" to "service_role";

grant select on table "public"."user_avatars" to "service_role";

grant trigger on table "public"."user_avatars" to "service_role";

grant truncate on table "public"."user_avatars" to "service_role";

grant update on table "public"."user_avatars" to "service_role";

grant delete on table "public"."user_cooldowns" to "anon";

grant insert on table "public"."user_cooldowns" to "anon";

grant references on table "public"."user_cooldowns" to "anon";

grant select on table "public"."user_cooldowns" to "anon";

grant trigger on table "public"."user_cooldowns" to "anon";

grant truncate on table "public"."user_cooldowns" to "anon";

grant update on table "public"."user_cooldowns" to "anon";

grant delete on table "public"."user_cooldowns" to "authenticated";

grant insert on table "public"."user_cooldowns" to "authenticated";

grant references on table "public"."user_cooldowns" to "authenticated";

grant select on table "public"."user_cooldowns" to "authenticated";

grant trigger on table "public"."user_cooldowns" to "authenticated";

grant truncate on table "public"."user_cooldowns" to "authenticated";

grant update on table "public"."user_cooldowns" to "authenticated";

grant delete on table "public"."user_cooldowns" to "service_role";

grant insert on table "public"."user_cooldowns" to "service_role";

grant references on table "public"."user_cooldowns" to "service_role";

grant select on table "public"."user_cooldowns" to "service_role";

grant trigger on table "public"."user_cooldowns" to "service_role";

grant truncate on table "public"."user_cooldowns" to "service_role";

grant update on table "public"."user_cooldowns" to "service_role";

grant delete on table "public"."user_selfies" to "anon";

grant insert on table "public"."user_selfies" to "anon";

grant references on table "public"."user_selfies" to "anon";

grant select on table "public"."user_selfies" to "anon";

grant trigger on table "public"."user_selfies" to "anon";

grant truncate on table "public"."user_selfies" to "anon";

grant update on table "public"."user_selfies" to "anon";

grant delete on table "public"."user_selfies" to "authenticated";

grant insert on table "public"."user_selfies" to "authenticated";

grant references on table "public"."user_selfies" to "authenticated";

grant select on table "public"."user_selfies" to "authenticated";

grant trigger on table "public"."user_selfies" to "authenticated";

grant truncate on table "public"."user_selfies" to "authenticated";

grant update on table "public"."user_selfies" to "authenticated";

grant delete on table "public"."user_selfies" to "service_role";

grant insert on table "public"."user_selfies" to "service_role";

grant references on table "public"."user_selfies" to "service_role";

grant select on table "public"."user_selfies" to "service_role";

grant trigger on table "public"."user_selfies" to "service_role";

grant truncate on table "public"."user_selfies" to "service_role";

grant update on table "public"."user_selfies" to "service_role";

grant delete on table "public"."user_videos" to "anon";

grant insert on table "public"."user_videos" to "anon";

grant references on table "public"."user_videos" to "anon";

grant select on table "public"."user_videos" to "anon";

grant trigger on table "public"."user_videos" to "anon";

grant truncate on table "public"."user_videos" to "anon";

grant update on table "public"."user_videos" to "anon";

grant delete on table "public"."user_videos" to "authenticated";

grant insert on table "public"."user_videos" to "authenticated";

grant references on table "public"."user_videos" to "authenticated";

grant select on table "public"."user_videos" to "authenticated";

grant trigger on table "public"."user_videos" to "authenticated";

grant truncate on table "public"."user_videos" to "authenticated";

grant update on table "public"."user_videos" to "authenticated";

grant delete on table "public"."user_videos" to "service_role";

grant insert on table "public"."user_videos" to "service_role";

grant references on table "public"."user_videos" to "service_role";

grant select on table "public"."user_videos" to "service_role";

grant trigger on table "public"."user_videos" to "service_role";

grant truncate on table "public"."user_videos" to "service_role";

grant update on table "public"."user_videos" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

grant delete on table "public"."videos" to "anon";

grant insert on table "public"."videos" to "anon";

grant references on table "public"."videos" to "anon";

grant select on table "public"."videos" to "anon";

grant trigger on table "public"."videos" to "anon";

grant truncate on table "public"."videos" to "anon";

grant update on table "public"."videos" to "anon";

grant delete on table "public"."videos" to "authenticated";

grant insert on table "public"."videos" to "authenticated";

grant references on table "public"."videos" to "authenticated";

grant select on table "public"."videos" to "authenticated";

grant trigger on table "public"."videos" to "authenticated";

grant truncate on table "public"."videos" to "authenticated";

grant update on table "public"."videos" to "authenticated";

grant delete on table "public"."videos" to "service_role";

grant insert on table "public"."videos" to "service_role";

grant references on table "public"."videos" to "service_role";

grant select on table "public"."videos" to "service_role";

grant trigger on table "public"."videos" to "service_role";

grant truncate on table "public"."videos" to "service_role";

grant update on table "public"."videos" to "service_role";

CREATE TRIGGER update_avatars_updated_at BEFORE UPDATE ON public.avatars FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_selfies_updated_at BEFORE UPDATE ON public.selfies FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


